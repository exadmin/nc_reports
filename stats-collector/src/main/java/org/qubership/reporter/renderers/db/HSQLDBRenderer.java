package org.qubership.reporter.renderers.db;

import org.qubership.reporter.inspectors.api.model.metric.Metric;
import org.qubership.reporter.inspectors.api.model.result.ReportModel;
import org.qubership.reporter.utils.DateUtils;
import org.qubership.reporter.utils.JDBCUtils;
import org.qubership.reporter.utils.TheLogger;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class HSQLDBRenderer {
    public static final String SQL_GET_ALL_COLUMNS_IN_NC_REPO_TABLE = "SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA='PUBLIC' AND TABLE_NAME='NC_REPORTS'";
    public static final String SQL_CHECK_IF_PUBLIC_SCHEMA_EXISTS = "SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = 'PUBLIC'";

    public void saveToDB(Connection jdbcConnection, ReportModel report) throws SQLException {
        ensureDB(jdbcConnection);

        List<String> existedColumnNames = JDBCUtils.doSingleColumnSelect(jdbcConnection, SQL_GET_ALL_COLUMNS_IN_NC_REPO_TABLE);
        List<String> nonExistedColumnNames = new ArrayList<>();

        // ensure each metric has it's column in the DB
        for (Metric metric : report.getMetrics()) {
            String metricName = metric.getPersistenceId();

            if (!existedColumnNames.contains(metricName)) {
                nonExistedColumnNames.add(metricName);
            }
        }

        if (!nonExistedColumnNames.isEmpty()) {
            for (String absentColumnName : nonExistedColumnNames) {
                JDBCUtils.executeDDL(jdbcConnection, "ALTER TABLE NC_REPORTS ADD COLUMN \"" + absentColumnName +"\" VARCHAR(255)");
            }
        }

        // do data store
        StringBuilder sql = new StringBuilder("INSERT INTO NC_REPORTS (DATE, REPO_NAME");
        StringBuilder binds = new StringBuilder("?, ?");

        for (Metric metric : report.getMetrics()) {
            sql.append(", \"").append(metric.getPersistenceId()).append("\"");
            binds.append(", ?");
        }
        sql.append(") VALUES (").append(binds).append(")");

        String dateStr = DateUtils.getCurrentDateTimeStamp();

        try (PreparedStatement pstm = jdbcConnection.prepareStatement(sql.toString())) {

            for (String repoName : report.getRepositoryNames()) {
                pstm.setString(1, dateStr);
                pstm.setString(2, repoName);

                TheLogger.debug("SQL QUERY = " + sql);

                int bindIndex = 3;
                for (Metric metric : report.getMetrics()) {
                    String value = report.getValue(repoName, metric.getPersistenceId()).getRawValue();
                    TheLogger.debug("Assign bind index = " + bindIndex + ", raw-str-value = " +  value);
                    pstm.setString(bindIndex, value);
                    bindIndex++;
                }

                pstm.addBatch();
                TheLogger.debug("Adding batch");
            }

            int[] result = pstm.executeBatch();
            TheLogger.debug("Batch execution result = " + Arrays.toString(result));
        }

    }

    private void ensureDB(Connection jdbcConnection) {
        List<String> existedColumnNames = JDBCUtils.doSingleColumnSelect(jdbcConnection, SQL_GET_ALL_COLUMNS_IN_NC_REPO_TABLE);

        if (!existedColumnNames.contains("UNIQUE_ID")) {
            TheLogger.debug("DataBase does not exist. Creating default tables.");
            String sql1 = "CREATE TABLE NC_REPORTS(UNIQUE_ID INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 0) NOT NULL PRIMARY KEY,DATE TIMESTAMP NOT NULL,REPO_NAME VARCHAR(255) NOT NULL)";
            String sql2 = "ALTER TABLE NC_REPORTS ALTER COLUMN UNIQUE_ID RESTART WITH 0";

            JDBCUtils.executeDDL(jdbcConnection, sql1);
            JDBCUtils.executeDDL(jdbcConnection, sql2);
        } else {
            TheLogger.debug("DataBase is found.");
        }
    }

}
